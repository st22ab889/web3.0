1. 数字货币要解决两个问题:
    1.1 货币的发行: 谁有权力发行 
        在比特币系统中, 是由挖矿来决定的.
        example：
            A 挖矿得到了10个比特币, 这是第一个交易,写进区块链
            A 给 B 和 C 分别 5 个比特币, 这个交易需要A的签名, 证明经过A的同意，还要说明 B和C的这10个比特币从哪得到的.
            B 转给 C 2 个，转给 D 3个,  这个交易需要B的签名, 证明经过B的同意，还要说明，C获得的2个比特币 以及 D 获得的3个比特币的来源.
            C 转个 E 7个 比特币.
            这些交易连在一起就构成了一个小型的区块链，这个区块链又两种hash指针:
                一种是连接各个交易(区块)之间的hash指针，连接起来构成一个链表.
                一种是指向前面的某个交易(比如E的7个比特币是第二步和第三步分别得到的5个比特币和2个比特币),说明了币的来源。这样就防止了"double spending attack"
        比特币系统中每个交易都包含输入和输出两部分:
            输入部分要说明币的来源，以及输入者的公钥
            输出部分要给出收款人的公钥的hash
        比特币中的账户地址是通过用户的公钥推算出来的(比如对公钥进行hash，然后经过一系列的转换),这个地址相当于银行的账号.
            支持比特币支付的网站，提供了支付二维码, 这个二维码就是比特币的支付地址.
    2.2 怎么防止交易的有效性: 防范 double spending attack 
        维护一个数据结构, 检测这个币以前有没有被花过, 被谁花过, 这个数据结构由所有的用户共同维护(去中心化)
        这个数据结构就是区块链

2. A 给 B 转账需要考虑的问题:
    A 有没有币给 B 转
    B 要知道 A 的公钥, 知道这钱从哪来的. 大家都需要知道 A 的公钥, 因为需要验证(私钥签名,公钥验证).

3. 在比特币系统中的验证过程是通过运行脚本(BitCoin Script)时间.
    每个交易的输入是一段脚本, 包括给出公钥也是在输入脚本中指定的.
    每个交易的输出也是一段脚本.
    验证是不是合法的,就需要把当前交易的输入脚本和前面的那个交易(提供币的来源的那个交易)的输出脚本拼在一起看能不能顺利运行,能顺利运行才是合法的.
    实际系统中,每个区块可以包含很多交易, 这些交易就组成"Merkle tree"

4. 每个区块分为两部分，块头(block header)和块身（block body）
    block header 包含的宏观信息:
        比特币版本协议
        指向前一个区块的区头(对整个区头取hash)的指针.
        整棵 的根hash值
        挖矿的难度目标域值, 准确的说是目标域值编码(nBits)  H(block header) <= target
        随机数值(nonce)
    block body 包含交易列表
        
5. 比特币系统中分为 Full Node 和 Light Node
    全节点保存区块链整个信息, 验证每个交易, 所以全节点也叫 fully validating node
    轻节点只保存 block header, 一般来说情节点无法独立验证交易的合法性, 比如说这个交易是不是 double spent attack , 因为没有存之前的交易信息
    系统中大多数节点是轻节点.这节课主要针对全节点,因为轻节点没有参与区块链的构造和维护.只是利用了区块链的一些信息做一些查询等操作

    区块链中包含的内容是怎么写入到区块链中的? 每个账户都可以发布交易,这个交易广播给所有的节点。有些交易合法,有些交易非法,谁来决定哪些交易应该被写到下一个区块中?按照什么顺序写进去? 需要用到比特币中的共识协议. 
    区块链是一个去中心化的账本, 这个账本中的内容要有统一的说法. 否则每个人记的帐可能不一样, 所以账本的内容要取得分布式的共识(distribution consen)

6. distribution consen(分布式共识): 多台机器共同维护分布式hash表. 分布式共识比较注明的协议是Paxos.
    比特币中的共识协议：按照计算力投票 
        每个节点都可以在本地组装出一个候选区块，把它人为合法的交易放在这个候选区块中. 然后尝试各种 nonce 值.
        block header 有个域是随机数nonce,组装后这个区块后就开始试各种nonce,看哪一个能满足 H(block header) <= target 这个不等式的要求.
        如果某个节点找到符合要求的 nonce, 就获得了记账权.
        记账权就是往比特币这个去中心化的账本里写入下一个区块的权利.
        只有找到这个nonce获得记账权的节点才有权力发布下一个区块.其它节点收到这个区块之后,需要验证这个区块的合法性.
            验证 block header 中的内容填的对不对. 比如 block header 有个域是 nBits, 实际上是 target 域值的编码. 检测 nBits 域设置的是不是符合比特币协议中规定的难度要求.
            检查下 nonce 是不是整个 block header 的 hash 是不是小于等于目标域值.
            验证 block body中的交易列表,看每个交易是不是合法的. 比如合法的签名, 以前没有花过(double spent attack).

    比特币中取得的共识是: 区中心账本化的内容要取的共识.
    谁能决定账本中的内容: 只有获得记账权的节点才能往账本中写东西.
    怎么获得记账权: 找nonce. 完全靠算力,看每秒能试多少个nonce数目(也成为hash rate), 决定了投票的权重. 这个节点的 hash rate 越高，获得记账权以及得到这个初块的奖励的概率也越大.

7. 下面内容从 1:06:00 开始看
   最长合法链(longest valid chain),比特币协议中规定接收的区块应该是扩展最长合法链
   forking attack(分叉攻击): 通过往区块链中间位置插入一个区块来回滚某个已经发生的交易.
   区块链正常情况也会发送分叉,两个节点同时获得记账权, 这时会出现两个等长的分叉.该接受哪个?比特币中缺省情况下,其它节点接受它最早收到的那一个.如果沿着这个区块继续扩展就是认可了发布的这个区块.
   没有认可的分支将会被抛弃, 当然也没有 block reward.
   
   争取记账权有什么好处:
      获取记账权的节点本身有一定的权力.可以决定哪些交易可以写进下一个区块中.
      block reward: 比特币协议中规定获得记账权的那个节点在发布的区块里可以有一个特殊的铸币交易(coinbase transaction)，这个交易里可以发布一定数量的比特币.
            铸币交易(coinbase transaction)是比特币中发行新的比特币的唯一方法.其它所有的交易都只不过是把已有的比特币从一个账户转移到另外一个账户.   
            比特币刚上线,每一个发布的区块可以产生 50 BTC (初块奖励50个比特币). 协议中规定 210000 个区块以后, 初块奖励就要减半. 再过 21000 个区块, 又要减半.
            这就是现在的情况,现在每个区块里只能产生 12.5 个比特币.

    比特币争夺记账权的过程称之为"挖矿"(mining).比特币也被称之为数字黄金(digital gold).所以求解 computational puzzle 去寻找这个 nonce 的过程称就相当于当初的淘金.
    找到合法的 nonce 获得记账权就能得到比特币,相当于挖到了金矿.争夺记账权的节点被称之为矿工(miner).获得记账权就说挖到矿(或挖到区块),区块链中的每个区块都是这样挖出来的.
    比特币系统中的挖矿过程和淘金挖矿的过程有很多类似之处, 都不容易, 都很幸苦, 都是在一个很大的搜索空间中去寻找, 找到的概率很小, 但是一旦找到就能赚一大笔钱.
    这就是加密货币世界中的玩法.




